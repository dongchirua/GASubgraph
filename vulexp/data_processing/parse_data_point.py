import networkx as nx
import csv


def joern_edge_to_edgelist(edge_file, relations):
    """ converts an edges.csv file generated by Joern into a simple edgelist """
    edge_list = {}
    with open(edge_file, 'r') as csv_file:
        csv_reader = csv.reader(csv_file, delimiter='\t')
        first_line = True
        for row in csv_reader:
            # Skip first line
            if first_line:
                first_line = False
                continue
            edge_type = row[2].strip()
            if edge_type in relations:
                if row[0] not in edge_list:
                    if row[3] == "":
                        edge_list[row[0]] = [(row[1], row[2])]
                    else:
                        edge_list[row[0]] = [(row[1], row[2], row[3])]
                else:
                    if row[3] == "":
                        edge_list[row[0]].append((row[1], row[2]))
                    else:
                        edge_list[row[0]].append((row[1], row[2], row[3]))
    return edge_list


def extract_line_number(row_node_file) -> int:
    """if a node has line number will return it, else return -1"""
    if row_node_file == '':
        return -1
    line_num = int(row_node_file.split(':')[0])
    return line_num


def find_nodes_in_edges(edges: dict):
    total = set()
    for i in edges.keys():
        total.add(i)
        for j in edges[i]:
            total.add(j[0])
    return total


def joern_to_networkx(nodes_file, edge_file, func_names=None,
                      types=('FLOWS_TO', 'REACHES')):
    """
        Converts a joern nodes.csv and edges.csv into a list of NetworkX graphs
        Consider relation in types only
    """

    edge_list = joern_edge_to_edgelist(edge_file, types)
    nodes_in_edges = find_nodes_in_edges(edge_list)
    graphs = []
    with open(nodes_file, 'r') as csv_file:
        csv_reader = csv.reader(csv_file, delimiter='\t')
        first_line = True
        second_line = True
        curr_meta = {}
        for row in csv_reader:
            # Skip first line
            if first_line:
                # header
                first_line = False
                continue
            if second_line:
                second_line = False
                code_file = '/'.join(row[3].split('/')[2:])
                continue
            if row[2] == "Function":
                # Found a new function
                # row[4] is function name
                # row[5] is function location in line_num:x:x:x
                if not func_names or row[3] in func_names:
                    curr_meta['location'] = row[4]
                    curr_meta['graph'] = nx.MultiDiGraph(name=row[3],
                                                         code_file=code_file)
                    curr_meta['name'] = row[3]
                    processing_func = True
            else:
                # not a function start.  so just see if we processing or not
                node_id = row[1]
                if processing_func and node_id in nodes_in_edges:
                    curr_meta['graph'].add_node(row[1])  # add node to graph
                    curr_meta['graph'].nodes[row[1]]['type'] = row[2].strip()
                    curr_meta['graph'].nodes[row[1]]['code'] = row[3]
                    curr_meta['graph'].nodes[row[1]]['line_num'] = extract_line_number(row[4])
        # end of csv file
        # lets check to make sure we didnt end on a function we were processing
        if processing_func:
            # need to finish off this function
            # add edges
            for src_n in curr_meta['graph'].nodes():
                if src_n in edge_list:
                    for edge in edge_list[src_n]:
                        if len(edge) < 3:
                            (dst_n, e_type) = edge
                            curr_meta['graph'].add_edge(src_n, dst_n, e_type=e_type, var='dummy')
                        else:
                            (dst_n, e_type, var) = edge
                            curr_meta['graph'].add_edge(src_n, dst_n, e_type=e_type, var=var)
            graphs.append(curr_meta)
            processing_func = False
    # now we have processed both the nodes.csv and edges.csv for this source code file
    return graphs


def read_code_file(file_path):
    """
    Helper to read code file
    :param file_path: path points to code file
    :return:
    """
    code_lines = {}
    with open(file_path) as fp:
        for ln, line in enumerate(fp):
            assert isinstance(line, str)
            line = line.strip()
            if '//' in line:
                line = line[:line.index('//')]
            code_lines[ln + 1] = line
        return code_lines
